//
// QRPhResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct QRPhResponse: Codable, JSONEncodable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case _static = "static"
        case _dynamic = "dynamic"
    }
    public enum Status: String, Codable, CaseIterable {
        case active = "active"
        case paid = "paid"
        case cancelled = "cancelled"
        case expired = "expired"
    }
    /** Unique identifier for the QRPh request. */
    public var id: String
    /** Client-provided reference for correlating the request. */
    public var referenceId: String
    /** QR code type, either static or dynamic. */
    public var type: ModelType
    public var amount: Int?
    public var submerchantId: String?
    /** Current status of the QRPh request. */
    public var status: Status
    public var metadata: [String: AnyCodable]?
    public var qrphPayload: String?
    public var qrphImage: String?
    public var checkoutUrl: String?
    public var paymentId: String?
    public var paidAt: String?
    public var expiresAt: String?
    public var cancelledAt: String?
    public var cancellationReason: String?
    /** ISO timestamp when the QRPh request was created. */
    public var createdAt: String
    /** ISO timestamp when the QRPh request was last updated. */
    public var updatedAt: String
    /** Indicates whether the request was created in live or test mode. */
    public var livemode: Bool

    public init(id: String, referenceId: String, type: ModelType, amount: Int? = nil, submerchantId: String? = nil, status: Status, metadata: [String: AnyCodable]? = nil, qrphPayload: String? = nil, qrphImage: String? = nil, checkoutUrl: String? = nil, paymentId: String? = nil, paidAt: String? = nil, expiresAt: String? = nil, cancelledAt: String? = nil, cancellationReason: String? = nil, createdAt: String, updatedAt: String, livemode: Bool) {
        self.id = id
        self.referenceId = referenceId
        self.type = type
        self.amount = amount
        self.submerchantId = submerchantId
        self.status = status
        self.metadata = metadata
        self.qrphPayload = qrphPayload
        self.qrphImage = qrphImage
        self.checkoutUrl = checkoutUrl
        self.paymentId = paymentId
        self.paidAt = paidAt
        self.expiresAt = expiresAt
        self.cancelledAt = cancelledAt
        self.cancellationReason = cancellationReason
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.livemode = livemode
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case referenceId = "reference_id"
        case type
        case amount
        case submerchantId = "submerchant_id"
        case status
        case metadata
        case qrphPayload = "qrph_payload"
        case qrphImage = "qrph_image"
        case checkoutUrl = "checkout_url"
        case paymentId = "payment_id"
        case paidAt = "paid_at"
        case expiresAt = "expires_at"
        case cancelledAt = "cancelled_at"
        case cancellationReason = "cancellation_reason"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
        case livemode
    }

    public var additionalProperties: [String: AnyCodable] = [:]

    public subscript(key: String) -> AnyCodable? {
        get {
            if let value = additionalProperties[key] {
                return value
            }
            return nil
        }

        set {
            additionalProperties[key] = newValue
        }
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(referenceId, forKey: .referenceId)
        try container.encode(type, forKey: .type)
        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(submerchantId, forKey: .submerchantId)
        try container.encode(status, forKey: .status)
        try container.encodeIfPresent(metadata, forKey: .metadata)
        try container.encodeIfPresent(qrphPayload, forKey: .qrphPayload)
        try container.encodeIfPresent(qrphImage, forKey: .qrphImage)
        try container.encodeIfPresent(checkoutUrl, forKey: .checkoutUrl)
        try container.encodeIfPresent(paymentId, forKey: .paymentId)
        try container.encodeIfPresent(paidAt, forKey: .paidAt)
        try container.encodeIfPresent(expiresAt, forKey: .expiresAt)
        try container.encodeIfPresent(cancelledAt, forKey: .cancelledAt)
        try container.encodeIfPresent(cancellationReason, forKey: .cancellationReason)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(livemode, forKey: .livemode)
        var additionalPropertiesContainer = encoder.container(keyedBy: String.self)
        try additionalPropertiesContainer.encodeMap(additionalProperties)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        id = try container.decode(String.self, forKey: .id)
        referenceId = try container.decode(String.self, forKey: .referenceId)
        type = try container.decode(ModelType.self, forKey: .type)
        amount = try container.decodeIfPresent(Int.self, forKey: .amount)
        submerchantId = try container.decodeIfPresent(String.self, forKey: .submerchantId)
        status = try container.decode(Status.self, forKey: .status)
        metadata = try container.decodeIfPresent([String: AnyCodable].self, forKey: .metadata)
        qrphPayload = try container.decodeIfPresent(String.self, forKey: .qrphPayload)
        qrphImage = try container.decodeIfPresent(String.self, forKey: .qrphImage)
        checkoutUrl = try container.decodeIfPresent(String.self, forKey: .checkoutUrl)
        paymentId = try container.decodeIfPresent(String.self, forKey: .paymentId)
        paidAt = try container.decodeIfPresent(String.self, forKey: .paidAt)
        expiresAt = try container.decodeIfPresent(String.self, forKey: .expiresAt)
        cancelledAt = try container.decodeIfPresent(String.self, forKey: .cancelledAt)
        cancellationReason = try container.decodeIfPresent(String.self, forKey: .cancellationReason)
        createdAt = try container.decode(String.self, forKey: .createdAt)
        updatedAt = try container.decode(String.self, forKey: .updatedAt)
        livemode = try container.decode(Bool.self, forKey: .livemode)
        var nonAdditionalPropertyKeys = Set<String>()
        nonAdditionalPropertyKeys.insert("id")
        nonAdditionalPropertyKeys.insert("reference_id")
        nonAdditionalPropertyKeys.insert("type")
        nonAdditionalPropertyKeys.insert("amount")
        nonAdditionalPropertyKeys.insert("submerchant_id")
        nonAdditionalPropertyKeys.insert("status")
        nonAdditionalPropertyKeys.insert("metadata")
        nonAdditionalPropertyKeys.insert("qrph_payload")
        nonAdditionalPropertyKeys.insert("qrph_image")
        nonAdditionalPropertyKeys.insert("checkout_url")
        nonAdditionalPropertyKeys.insert("payment_id")
        nonAdditionalPropertyKeys.insert("paid_at")
        nonAdditionalPropertyKeys.insert("expires_at")
        nonAdditionalPropertyKeys.insert("cancelled_at")
        nonAdditionalPropertyKeys.insert("cancellation_reason")
        nonAdditionalPropertyKeys.insert("created_at")
        nonAdditionalPropertyKeys.insert("updated_at")
        nonAdditionalPropertyKeys.insert("livemode")
        let additionalPropertiesContainer = try decoder.container(keyedBy: String.self)
        additionalProperties = try additionalPropertiesContainer.decodeMap(AnyCodable.self, excludedKeys: nonAdditionalPropertyKeys)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension QRPhResponse: Identifiable {}
